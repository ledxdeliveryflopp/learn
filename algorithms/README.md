# Блок об алгоритмах

**O-big** - обозначение "сложность" алгоритма, т.е необходимое количество итераций для совершения действия.
**O(1)** > **O(log n)** > **O(n)** > **O(n log n)** > **O(n^2)** > **O(n!)**
(Константное время, логарифмическое время, линейное время, линейно-логарифмическое время, квадратичное время, факториальное время)

**Двоичный поиск** — Поиск по алгоритму который каждую итерацию берет число из центра массива и сравнивает его с искомым,
если искомое число меньше, то правая граница смещается до этого числа(которое было в середине массива), если искомое число
больше, то левая граница смещается до этого числа и так происходит пока не будет найдено число(все время делим массив на 2 части)
**O(log n)**

**Быстрая сортировка** — Сортировка массива в котором определятся опорный элемент(как правило середина массива), и создаются
массив который: больше опорного, меньше и равен(если не нужно удалять дубликаты цифр) и рекурсивно сортируется массив
больше и меньше опорного элемента, и после меньший массив + массив равный опорному + массив больше опорного.
(Если опорный элемент взять за 0 индекс то при попытке сортировки уже отсортированного массива меньше подмассив будет
пустым и будет большим стек вызовов или будет переполнение стека)
(Если опорный элемент взять за среднее число в массиве, то это будет не эффективно тк высчитывать среднее число труднозатратно)
(При рекурсивном методе есть риск переполнения стека вызов при слишком большом массиве)
**O(n^2)** - худший случай
**O(n log n)** - средний/лучший случай

**Поиск в ширину(Графы)** — Поиск кратчайшего пути между 2 объектами, алгоритм отвечает на вопросы:
существует ли путь от узла A к узлу B и как выглядит кратчайший путь от узла A к узлу B? Создается список объектов(друзей) для поиска(**1 уровень**)
и очередь проверки(что-бы искать нужного человека в списке друзей друга)(**2 уровень и тд**), если не будет найден друг в 1 уровне
то в очередь добавятся друзья этого друга и поиск продолжится в 1 уровне пока он не дойдет до 2 уровня(**друзья друзей**)
и так пока не будет найден нужный объект или он не будет найден.
**Граф** = дерево с обратными связями
**Дерево** = граф без обратных связей
**O(V + E)** - средний/лучший случай (V - вершины(количество объектов), E - ребра(количество связей))

